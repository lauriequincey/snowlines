/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var geometry = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[2.56224428617025, 63.08266932911727],
          [2.56224428617025, 60.25381667427237],
          [11.83470522367025, 60.25381667427237],
          [11.83470522367025, 63.08266932911727]]], null, false);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
/** Transect Geometry **/

// Declare Transect Length with Line Geometry
var transect_line = ee.Geometry.LineString(
  [[4.88,  61.7],
   [9.13,   61.7]]
  );

// Declare Transect Width
// Info: Units in metres
var transect_width = 40000;

// Generate Geodesic Multi-Direction Rectangular Transect Area
// Info: Takes the line, buffers it. The buffered shape always has the same number of vertices. Use the vertices above and below the end of the line to make a rectangle which is geodesic. Allows for drawing a transect at any angle not just inline with latitude or longitude.
var buffered_transect_line = transect_line.buffer(transect_width / 2);
var buffered_transect_line_coords = ee.List(buffered_transect_line.coordinates().get(0));
var lt_coord = ee.Geometry.Point(ee.List(buffered_transect_line_coords.get(0)));  // left top
var lb_coord = ee.Geometry.Point(ee.List(buffered_transect_line_coords.get(11))); // left bottom
var rb_coord = ee.Geometry.Point(ee.List(buffered_transect_line_coords.get(13))); // right bottom
var rt_coord = ee.Geometry.Point(ee.List(buffered_transect_line_coords.get(24))); // right top
var transect = ee.Geometry.Polygon({
  coords:   [lt_coord, lb_coord, rb_coord, rt_coord],
  geodesic: true,
});
Map.centerObject(transect);
Export.table.toAsset({
  collection: ee.FeatureCollection(transect),
  description: "transect",
  assetId: "transect"
})

/** Curate Imagery Collection **/
// Input Date
// Info:  Do not use 2020 and over or 1984 or below dates as satellites do not cover this.
//        Do not use cross year dates as the imagery is likely too bad in the Northern Hemisphere winter and I haven't bothered implementing an 'add year to end date' function so it won't work.
//        The start dates below are used in the study.

//var start_date = ee.Date('1982-07-16'); // at 16 days - 4: no, 5: no 
//var start_date = ee.Date('1983-08-11'); // at 16 days - 4: no, 5: no
//var start_date = ee.Date('1984-07-15'); // at 16 days - 4: no, 5: partial (out of phase)
//var start_date = ee.Date('1985-07-10'); // at 16 days - 4: no, 5: no
//var start_date = ee.Date('1987-08-23'); // at 16 days - 4: no, 5: no
//var start_date = ee.Date('1988-06-26'); // at 16 days - 4: no, 5: yes
//var start_date = ee.Date('1989-07-24'); // at 16 days - 4: no, 5: yes
//var start_date = ee.Date('1990-09-01'); // at 16 days - 4: no, 5: no (out of phase) 
//var start_date = ee.Date('1991-07-22'); // at 16 days - 4: no, 5: yes 
//var start_date = ee.Date('1992-06-27'); // at 16 days - 4: no, 5: yes
//var start_date = ee.Date('1993-07-19'); // at 16 days - 4: no, 5: partial 
//var start_date = ee.Date('1994-07-25'); // at 16 days - 4: no, 5: yes 
//var start_date = ee.Date('1995-07-20'); // at 16 days - 4: no, 5: yes
//var start_date = ee.Date('1996-07-04'); // at 16 days - 4: no, 5: no 
//var start_date = ee.Date('1997-07-13'); // at 16 days - 4: , 5: partial
//var start_date = ee.Date('1998-07-23'); // at 16 days - 4: no , 5: yes
//var start_date = ee.Date('1999-07-29'); // at 16 days - 5: yes, 7: yes 
//var start_date = ee.Date('2000-07-17'); // at 16 days - 5: yes, 7: yes 
//var start_date = ee.Date('2001-06-28'); // at 16 days - 5: no, 7: no 
//var start_date = ee.Date('2002-07-05'); // at 16 days - 5: no, 7: partial 
//var start_date = ee.Date('2003-07-12'); // at 16 days - 5: yes , 7: no 
//var start_date = ee.Date('2004-07-27'); // at 16 days - 5: yes , 7: yes 
//var start_date = ee.Date('2005-08-03'); // at 16 days - 5: no, 7: no
//var start_date = ee.Date('2006-06-29'); // at 16 days - 5: partial, 7: no 
//var start_date = ee.Date('2007-07-08'); // at 16 days - 5: no, 7: no 
//var start_date = ee.Date('2008-07-22'); // at 16 days - 5: yes, 7: no 
//var start_date = ee.Date('2009-07-25'); // at 16 days - 5: no , 7: no 
//var start_date = ee.Date('2010-07-04'); // at 16 days - 5: no, 7: no 
//var start_date = ee.Date('2011-07-07'); // at 16 days - 5: partial, 7: partial 
//var start_date = ee.Date('2012-08-02'); // at 16 days - 7 partial: 
//var start_date = ee.Date('2013-07-14'); // at 16 days - 7: yes, 8: yes
//var start_date = ee.Date('2014-07-11'); // at 16 days - 7: yes, 8: yes
//var start_date = ee.Date('2015-08-18'); // at 16 days - 7: yes, 8: yes
//var start_date = ee.Date('2016-06-15'); // at 16 days - 7: partial, 8: no
//var start_date = ee.Date('2017-07-03'); // at 16 days - 7: no, 8: partial
//var start_date = ee.Date('2018-06-02'); // at 16 days - 7: yes, 8: partial
//var start_date = ee.Date('2019-06-27'); // at 16 days - 7: yes, 8: no
//var start_date = ee.Date('2020-06-27'); // at 16 days - 7: no, 8: yes
//var start_date = ee.Date('2021-07-08'); // at 16 days - 7: no, 8: yes

// Create a date range from this start date by using start date and advancing it by 13 days to find the end date.
var date_range = ee.DateRange(start_date, start_date.advance(16, 'day'));

// Pick a Satellite
// Info:  Match satellite date to the previously picked date range.
//        There will always be two choices of satellite for any satellite post 1984.
//        Dates:  Landsat 4: '1982-08-22', '1993-12-14'
//                Landsat 5: '1984-01-01', '2012-05-05'
//                Landsat 7: '1999-01-01', '2021-07-31'
//                Landsat 8: '2013-04-11', '2021-08-14'
var satellite_name = 'Landsat_8';

// Import Imagery Based on Date and Satellite Selection
var collections = ee.Dictionary([
  'Landsat_4', ee.ImageCollection('LANDSAT/LT04/C02/T1_L2')
    .filterBounds(transect)
    .filterDate(date_range)
    .select(['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'ST_B6', 'QA_PIXEL'],
            ['Blue', 'Green', 'Red', 'NIR', 'SWIR_1', 'SWIR_2', 'TIR', 'QA_PIXEL']),
  'Landsat_5', ee.ImageCollection('LANDSAT/LT05/C02/T1_L2')
    .filterBounds(transect)
    .filterDate(date_range)
    .select(['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'ST_B6', 'QA_PIXEL'],
            ['Blue', 'Green', 'Red', 'NIR', 'SWIR_1', 'SWIR_2', 'TIR', 'QA_PIXEL']),
  'Landsat_7', ee.ImageCollection('LANDSAT/LE07/C02/T1_L2')
    .filterBounds(transect)
    .filterDate(date_range)
    .select(['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'ST_B6', 'QA_PIXEL'], 
            ['Blue', 'Green', 'Red', 'NIR', 'SWIR_1', 'SWIR_2', 'TIR', 'QA_PIXEL']),
  'Landsat_8', ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
    .filterBounds(transect)
    .filterDate(date_range)
    .select(['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'ST_B10', 'QA_PIXEL'],
            ['Blue', 'Green', 'Red', 'NIR', 'SWIR_1', 'SWIR_2', 'TIR', 'QA_PIXEL'])
]);
var collection = ee.ImageCollection(collections.get(satellite_name));
Map.addLayer(collection, {}, 'Raw Imagery');

// Extract Cloud and Cloud Shadows Mask
var collection = collection.map(function(image) {
  var clouds = image.select('QA_PIXEL').bitwiseAnd(1 << 3).eq(0);
  var cloud_shadows = image.select('QA_PIXEL').bitwiseAnd(1 << 4).eq(0);
  var combined = ee.Image.constant(1).updateMask(clouds.and(cloud_shadows)).rename('clouds_and_cloud_shadows_mask');
  return image.addBands(combined.unmask());
});

// Add Unix Time to Each Pixel
var collection = collection.map(function(image) {
  return image.addBands(
    ee.Image.constant(ee.Date(image
      .get('DATE_ACQUIRED'))
      .millis()
    )
    .int64()
    .rename('aqcuisition_time')
  );
});

// Mosaic Imagery
var quality_mosaic = collection.qualityMosaic('clouds_and_cloud_shadows_mask');
Map.addLayer(quality_mosaic)

// Applies scaling factors.
function applyScaleFactors(image) {
  var opticalBands = image.select(['Red', 'Green', 'Blue']).multiply(0.0000275).add(-0.2);
  //var thermalBands = image.select('ST_B.*').multiply(0.00341802).add(149.0);
  return image.addBands(opticalBands, null, true)
             // .addBands(thermalBands, null, true);
}

quality_mosaic = ee.ImageCollection(quality_mosaic).map(applyScaleFactors);
//Map.addLayer(quality_mosaic.first().select(['Red', 'Green', 'Blue']).rgbToHsv())

var visualization = {
  bands: ['Red', 'Green', 'Blue'],
  min: 0.0,
  max: 0.4,
};

Map.addLayer(quality_mosaic, visualization, 'True Color (432)');
var export_image = ee.Image(quality_mosaic.first()).select(['Blue', 'Green', 'Red']);
print(export_image.projection())

Export.image.toDrive({
  image: export_image.visualize(visualization),
  description: 'image',
  fileNamePrefix: 'quality_mosaic',
  region: geometry,
  scale: 30,
  fileFormat: 'GEOTIFF',
  maxPixels: 10000000000,
  crs: 'EPSG:4326'
  });